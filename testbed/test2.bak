#include <iostream>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>
#include <math.h>
#include "omp.h"

#define NOBJS 500000 // Needs to be <= 500000 to fit on the heap
#define NDIM 2
#define SEED 4910581468146

int ix(int x, int y);
void print_array(double * a);
void populate(double * vec, gsl_rng ** rng);

int main() {

  // Initialize random number generators
  gsl_rng_env_setup();
  // Allocate to heap (prevent stack overflow for large NOBJ)
  gsl_rng **rng = new gsl_rng*[NOBJS];
  for (int i=0; i<NOBJS; ++i) {
   rng[i] = gsl_rng_alloc(gsl_rng_taus);
   gsl_rng_set(rng[i], (i+1)*SEED);
  }
  // Populate object positions
  double obj_pos[NOBJS*NDIM];
  populate(obj_pos, rng);

  // **** DO STUFF HERE **** //

  // **** DO STUFF HERE **** //

  delete rng;
  return 0;
}

void populate(double * vec, gsl_rng ** rng) {
#pragma omp parallel
  {
    int threadnum = omp_get_thread_num();
    int numthreads = omp_get_num_threads();
    int low = NOBJS*threadnum/numthreads;
    int high = NOBJS*(threadnum+1)/numthreads;
    for (int k=0; k<100; ++k)
    for (int i=low; i<high; ++i) {
      for (int j=0; j<NDIM; ++j) {
        vec[ix(i,j)] = gsl_rng_uniform_pos(rng[i]);
      }
    }
  }
}

void print_array(double * a) {
  printf("{ ");
  for (int i=0; i<NOBJS*NDIM; ++i) {
    printf("%1.3f ",a[i]);
  }
  printf("}\n");
}

int ix(int x, int y) {
  return x*NDIM + y;
}

